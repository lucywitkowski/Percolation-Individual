#The following code is adapted from Anders Malthe-SÃ¸renssen,
#'Percolation theory using Python', Section 11.2

import numpy as np
import numba
import matplotlib.pyplot as plt


@numba.njit(cache=True)
def percwalk(cluster, max_steps):

    walker_map = np.zeros((2, max_steps))
    displacement = np.zeros_like(walker_map)

    directions = np.zeros((2, 4), dtype=np.int64)
    neighbor_arr = np.zeros(4, dtype=np.int64)

    # X-dir: east and west, Y-dir: north and south.
    directions[0, 0] =  1
    directions[1, 0] =  0

    directions[0, 1] = -1
    directions[1, 1] =  0

    directions[0, 2] =  0
    directions[1, 2] =  1

    directions[0, 3] =  0
    directions[1, 3] = -1

    # Initial random position
    Lx, Ly = cluster.shape
    ix = np.random.randint(Lx)
    iy = np.random.randint(Ly)

    walker_map[0, 0] = ix
    walker_map[1, 0] = iy

    step = 0

    # Not in cluster to start with 
    if not cluster[ix, iy]:
        return walker_map, displacement, step

    while step < max_steps - 1:

        # Make list of valid moves
        neighbor = 0
        for idir in range(directions.shape[1]):
            dr = directions[:, idir]
            iix = ix + dr[0]
            iiy = iy + dr[1]

            if (0 <= iix < Lx and
                0 <= iiy < Ly and
                cluster[iix, iiy]):

                neighbor_arr[neighbor] = idir
                neighbor += 1

        # No places to move
        if neighbor == 0:
            return walker_map, displacement, step

        # Select random valid direction 
        randdir = np.random.randint(neighbor)
        dir = neighbor_arr[randdir]

        ix += directions[0, dir]
        iy += directions[1, dir]

        step += 1
        walker_map[0, step] = ix
        walker_map[1, step] = iy
        displacement[:, step] = displacement[:, step - 1] + directions[:, dir]

    return walker_map, displacement, step




import matplotlib.animation as animation

#### ANIMATE A RANDOM WALK ####
# parameters
L = 50
p = 1
z = np.random.rand(L, L) < p

steps = 0
while steps < 2:
    walker_map, displacement, steps = percwalk(z, 200)

fig, ax = plt.subplots(figsize=(5, 5))

ax.imshow(
    z.astype(int),
    origin="lower",
    cmap="gray",
    vmin=0,
    vmax=1
)

ax.set_title(f"$p={p}$")
ax.set_xlabel("y")
ax.set_ylabel("x")
ax.set_aspect("equal")

# Point for current walker position
point, = ax.plot([], [], 'ro', markersize=5)

# Trail of the walk
trail, = ax.plot([], [], 'r-', linewidth=1)

def update(frame):
    if frame == 0:
        return point, trail

    y = walker_map[1, :frame]
    x = walker_map[0, :frame]

    point.set_data([y[-1]], [x[-1]])
    trail.set_data(y, x)

    return point, trail

ani = animation.FuncAnimation(
    fig,
    update,
    frames=steps,
    interval=100,   # milliseconds between steps
    blit=True
)
ani.save("random_walk_p1.gif", writer="pillow", fps=10)


plt.show()
